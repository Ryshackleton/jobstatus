{"version":3,"file":"main.0ac4be6ec60fff206393.bundle.js","sources":["webpack:///./src/components/DotBarChart/utils/computeLayout.js"],"sourcesContent":["import { scaleBand, scaleLinear } from 'd3-scale';\n\nconst optRadius = ({ bandwidth, height, margin, maxNodesPerBar }) => {\n  // how much area do we have per bar\n  const totalBarArea = bandwidth * (height - margin.top - margin.bottom);\n  const areaPerSquare = totalBarArea / maxNodesPerBar;\n  // radius will be half the side of the square\n  return Math.sqrt(areaPerSquare) * 0.5;\n};\n\nexport default ({\n  bandPaddingInner = 0.5,\n  bandPaddingOuter = 0.7,\n  isHangingBar = true,\n  groupIndexPropName = 'groupIndex',\n  groupPropName,\n  groupKeys,\n  height,\n  margin = { top: 10, right: 10, bottom: 10, left: 10 },\n  nodeCount,\n  radiusToPaddingRatio = 0.9,\n  width,\n}) => {\n  // determine x scale based on the width and number of groups\n  const xScale = scaleBand()\n    .domain(groupKeys)\n    .range([margin.left, width - margin.right])\n    .paddingInner([bandPaddingInner])\n    .paddingOuter([bandPaddingOuter]);\n\n  // optimum radius and radius padding, given the amount of space we have\n  const radiusAndPadding = optRadius({\n    bandwidth: xScale.bandwidth(),\n    height,\n    maxNodesPerBar: nodeCount,\n    margin,\n    width,\n  });\n  // divide radius and padding up according to user defined ratio\n  const radius = radiusAndPadding * radiusToPaddingRatio;\n\n  // constants to compute the x and y positions from a node indexed by group\n  const diameter = radiusAndPadding * 2;\n  const outerSpace = xScale.step() * xScale.paddingOuter();\n  const nNodesPerRow = Math.ceil(xScale.bandwidth() / diameter);\n\n  const xAccessor = (node) => {\n    const xOff = (Math.floor(node[groupIndexPropName] % nNodesPerRow) * diameter) + radiusAndPadding - outerSpace;\n    return xScale(node[groupPropName])+ xOff;\n  };\n\n  const yRange = [height - margin.bottom, margin.top];\n  const yScale = scaleLinear()\n    .domain([0, height])\n    .range(isHangingBar ? yRange.reverse() : yRange);\n\n  const yAccessor = (node) => {\n    const rowN = Math.ceil((node[groupIndexPropName] + 1) / nNodesPerRow);\n    return yScale(rowN * diameter);\n  };\n\n  const radiusAccessor = () => (radius);\n\n  return {\n    radiusAccessor,\n    xAccessor,\n    xScale,\n    yAccessor,\n  };\n};\n"],"mappings":"AAUA","sourceRoot":""}